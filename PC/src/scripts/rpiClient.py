###############################################
##      AUTHOR : FAISAL FAZAL-UR-REHMAN      ##
###############################################
# Used for connecting to the socket server on #
# the RPI (controlServer). This client sits   #
# at the end of the PC side of software and   #
# sends action generated by the DQN to the    #
# control software on RPI.                    #                       
###############################################
##                    PC                     ##
###############################################

import socket

HEADER_SIZE = 10        # empty space between message size and the message
SHUTDOWN_CODE = 147258  # This number is used through out the RoboCon software which tells each script to shutdown

#___BEGIN CLASS RPICLIENT______________________________________________________________________________________________________
class RpiClient:


    #___Constructor
    def __init__(self, port_num=1236, host_name='pi'): # initiate client with default port number and hostname if not provided 
        self.hostName = host_name                      # store hostname in member variable
        self.port = port_num                           # store port number in member variable



    #___Destructor
    def __del__(self):
        print("SHUTTING RPI CLIENT AND SERVER DOWN")
        new_msg = True                                 # reset variable
        full_msg = ""                                  # clear variable
        
        msg = SHUTDOWN_CODE                            # set message to send as the shutdown code
        msg = str(msg)                                 # convert int to string
        msg = f"{len(msg):<{HEADER_SIZE}}"+msg         # concatiniate message in front of message size and header space
        
        self.s.send(bytes(msg,"utf-8"))                # send message to the server
        
        #-----------------

        msgReceived = False                            # clear variable, used as exit condition
        while (not msgReceived):                        
            msgRcv = self.s.recv(16)                   # wait for message received confirmation from the server

            if (new_msg):                              # enter if current message in buffer is a new one
                msglen = int(msgRcv[:HEADER_SIZE])     # extract expected message length
                new_msg = False                        # set flag to indicate current message is not new 
            
            full_msg += msgRcv.decode("utf-8")         # convert message encoding

            if (len(full_msg) >= msglen + HEADER_SIZE):         # Enter if full message received (i.e. length received has reached expected length)

                #___DEBUG___________________________________________________________________
                # print("Message from RPI : {}".format(full_msg))                         ##
                # print("Relevant message : {}".format(full_msg[HEADER_SIZE+msglenstr:])) ##
                ############################################################################

                msgReceived = True  # set flag to exit loop
                full_msg = ""       # clear variable
                new_msg = True      # reset variable



    #___Client thread routine as member function takes 2 deque as arguments / parameters
    def routine(self, data2rpiQue,rpiTaskCompleteQue):
        
        #___Connect to server 
        controlServerFound = False                                              # exit condition boolean   
        while (not controlServerFound):                                         # loop until connection is established
            try:
                self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)      # create socket, AF_INET = IPV4 and SOCK_STREAM = TCP
                self.s.connect((self.hostName,self.port))                       # attempt to connect to the server 
                controlServerFound = True                                       # if this is reached then connection has been established     
            except:
                controlServerFound = False                                      # if this is reached then connection failed

        new_msg = True                                                          # set variable for a new message
        full_msg = ""                                                           # define variable that will hold full message from server
        done = False                                                            # exit condition variable
        while (not done):                                                       # main loop for the routine
            numFlag = False                                                     # loop exit condition variable
            while(not numFlag):                                                 # keep in loop until action received is a vaild one
                try:
                    msg = data2rpiQue.get()                                     # get message (action) from DQN  
                    print(f"==============>>>>msg to send to RPI : {msg}")      
                    if ((msg <= 7) and (msg >= 1) or (msg == SHUTDOWN_CODE)):   # enter if action is valid or shutdown code
                        numFlag = True                                          # set flag to exit loop
                    elif(msg != 0):                                             # enter if action was invalid and not shutdown code or = 0
                        raise Exception("Error: in rpiClient, RoboCon move is invalid, must be between 1 to 7") # raise exception 
                except:
                    numFlag = False                                             # keep in loop if and exception was thrown 
                    raise Exception("Error: in rpiClient, RoboCon move is invalid, must be between 1 to 7 or equal to SHUTDOWN_CODE")
            
            msg = str(msg)                          # set message as action received from DQN
            msg = f"{len(msg):<{HEADER_SIZE}}"+msg  # concatinate message after length of message and header size spaces
            self.s.send(bytes(msg,"utf-8"))         # convert message encoding

            if (msg == SHUTDOWN_CODE):              # enter if action is shutdown code sent by DQN
                done = True                         # set exit condition to exit loop
            
            #-----------------

            msgReceived = False                                # exit condition boolean for loop that receives reply from server 
            while (not msgReceived):
                msgRcv = self.s.recv(16)                       # wait for reply from server on the RPI
                
                if (new_msg):                                  # enter if its a new message
                    msglen = int(msgRcv[:HEADER_SIZE])         # extract expected message length
                    msglenstr = len(str(abs(msglen)))          # convert message length from int to string
                    new_msg = False                            # indicates that current message is not new  
                
                full_msg += msgRcv.decode("utf-8")             # convert message encoding

                if (len(full_msg) >= msglen + HEADER_SIZE):    # Enter if full message received (i.e. length received has reached expected length)
                    print("Message from RPI : {}".format(full_msg)) 
                    msgReceived = True                         # set exit condition to exit the loop
                    full_msg = ""                              # clear variable
                    new_msg = True                             # reset variable
                    rpiTaskCompleteQue.put(1)                  # indicate DQN that required task has been completed 
                    if (done):                                 # if shutdown code was received as action from DQN done = True
                        break                                  # force exit current loop
            if (done):                                          
                break                                          # exit thread routine
